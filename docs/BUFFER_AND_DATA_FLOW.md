# Buffer Usage and Complete Data Flow Explanation

## ğŸ” Where Buffers Are Used

Your design uses **3 main data buffers** (128-bit registers):

### 1. **PT Buffer** (Plaintext Buffer) - Line 3182
```verilog
reg [127:0] PT;  // Plaintext buffer in pcpi_aes module
```
**Purpose:** Stores plaintext BEFORE encryption
**Size:** 128 bits (4Ã—32-bit words)
**Location:** `picorv32.v` line 3182, inside `pcpi_aes` module

### 2. **KEY Buffer** (Key Buffer) - Line 3182
```verilog
reg [127:0] KEY;  // Key buffer in pcpi_aes module
```
**Purpose:** Stores encryption key BEFORE encryption
**Size:** 128 bits (4Ã—32-bit words)
**Location:** `picorv32.v` line 3182, inside `pcpi_aes` module

### 3. **RESULT Buffer** (Ciphertext Buffer) - Line 3182
```verilog
reg [127:0] RESULT;  // Ciphertext buffer in pcpi_aes module
```
**Purpose:** Stores ciphertext AFTER encryption for SPI transmission and CPU read-back
**Size:** 128 bits (16 bytes)
**Location:** `picorv32.v` line 3182, inside `pcpi_aes` module

---

## ğŸ“Š Complete Data Flow with Buffers

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          COMPLETE DATA FLOW                                    â”‚
â”‚                    (Following actual code structure)                           â”‚
â”‚                                                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ STEP 1: CPU Loads Data into Buffers (Software)                          â”‚  â”‚
â”‚  â”‚         Using custom instructions via PCPI interface                     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                â”‚
â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                           â”‚
â”‚      â”‚   CPU       â”‚                                                           â”‚
â”‚      â”‚ Registers   â”‚                                                           â”‚
â”‚      â”‚  x0-x31     â”‚                                                           â”‚
â”‚      â”‚ (32-bit)    â”‚                                                           â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                                           â”‚
â”‚             â”‚ pcpi_rs1 (word index: 0,1,2,3)                                   â”‚
â”‚             â”‚ pcpi_rs2 (32-bit data word)                                      â”‚
â”‚             â”‚ pcpi_insn (instruction code)                                     â”‚
â”‚             â–¼                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         PCPI Interface (Co-Processor Bus)                               â”‚  â”‚
â”‚  â”‚         â€¢ pcpi_valid = 1 (when instruction is valid)                    â”‚  â”‚
â”‚  â”‚         â€¢ pcpi_insn  = instruction encoding                             â”‚  â”‚
â”‚  â”‚         â€¢ pcpi_rs1   = word index (0-3)                                 â”‚  â”‚
â”‚  â”‚         â€¢ pcpi_rs2   = 32-bit data                                      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                        â”‚                                                       â”‚
â”‚                        â–¼                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              pcpi_aes Module (Co-Processor)                             â”‚  â”‚
â”‚  â”‚                                                                         â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚ Instruction: AES_LOAD_PT (Load Plaintext Word)                   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚ Code location: Lines 3257-3269                                   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚                                                                  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚ Executed 4 times (word_index = 0, 1, 2, 3):                     â”‚  â”‚  â”‚
â”‚  â”‚  â”‚   case (word_index)                                              â”‚  â”‚  â”‚
â”‚  â”‚  â”‚     2'd0: PT[31:0]   <= pcpi_rs2;   // First word  (LSB)        â”‚  â”‚  â”‚
â”‚  â”‚  â”‚     2'd1: PT[63:32]  <= pcpi_rs2;   // Second word              â”‚  â”‚  â”‚
â”‚  â”‚  â”‚     2'd2: PT[95:64]  <= pcpi_rs2;   // Third word               â”‚  â”‚  â”‚
â”‚  â”‚  â”‚     2'd3: PT[127:96] <= pcpi_rs2;   // Fourth word (MSB)        â”‚  â”‚  â”‚
â”‚  â”‚  â”‚   endcase                                                        â”‚  â”‚  â”‚
â”‚  â”‚  â”‚                                                                  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚   Result: PT Buffer filled with 128-bit plaintext               â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚                                                                         â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚ Instruction: AES_LOAD_KEY (Load Key Word)                        â”‚  â”‚  â”‚
â”‚  â”‚  â”‚ Code location: Lines 3270-3282                                   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚                                                                  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚ Executed 4 times (word_index = 0, 1, 2, 3):                     â”‚  â”‚  â”‚
â”‚  â”‚  â”‚   case (word_index)                                              â”‚  â”‚  â”‚
â”‚  â”‚  â”‚     2'd0: KEY[31:0]   <= pcpi_rs2;   // First word  (LSB)       â”‚  â”‚  â”‚
â”‚  â”‚  â”‚     2'd1: KEY[63:32]  <= pcpi_rs2;   // Second word             â”‚  â”‚  â”‚
â”‚  â”‚  â”‚     2'd2: KEY[95:64]  <= pcpi_rs2;   // Third word              â”‚  â”‚  â”‚
â”‚  â”‚  â”‚     2'd3: KEY[127:96] <= pcpi_rs2;   // Fourth word (MSB)       â”‚  â”‚  â”‚
â”‚  â”‚  â”‚   endcase                                                        â”‚  â”‚  â”‚
â”‚  â”‚  â”‚                                                                  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚   Result: KEY Buffer filled with 128-bit key                    â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚                                                                         â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚  â”‚
â”‚  â”‚  â”‚              DATA BUFFERS (After Loading)                     â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  PT Buffer [127:0]  = Plaintext (Ready to encrypt)     â”‚  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ [127:96â”‚ [95:64]â”‚ [63:32]â”‚ [31:0] â”‚                 â”‚  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  Word3 â”‚  Word2 â”‚  Word1 â”‚  Word0 â”‚                 â”‚  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚                                                               â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  KEY Buffer [127:0] = Encryption Key                    â”‚  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ [127:96â”‚ [95:64]â”‚ [63:32]â”‚ [31:0] â”‚                 â”‚  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  Key3  â”‚  Key2  â”‚  Key1  â”‚  Key0  â”‚                 â”‚  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ STEP 2: CPU Triggers Encryption (AES_START instruction)                 â”‚  â”‚
â”‚  â”‚         Code location: Lines 3283-3312                                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                â”‚
â”‚      CPU executes: AES_START                                                   â”‚
â”‚                    â”‚                                                           â”‚
â”‚                    â–¼                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ pcpi_aes FSM: IDLE â†’ START_AES â†’ WAIT_AES                              â”‚  â”‚
â”‚  â”‚   â€¢ aes_encrypt = 1 (trigger signal to AES core)                       â”‚  â”‚
â”‚  â”‚   â€¢ Data flows from buffers PT and KEY into AES core                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                    â”‚                                                           â”‚
â”‚                    â”‚ PT[127:0] (from buffer)                                   â”‚
â”‚                    â”‚ KEY[127:0] (from buffer)                                  â”‚
â”‚                    â”‚ encrypt=1 (trigger)                                       â”‚
â”‚                    â–¼                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              AES ENCRYPTION CORE (ASMD_Encryption)                      â”‚  â”‚
â”‚  â”‚              Code location: Lines 3198-3206                             â”‚  â”‚
â”‚  â”‚                                                                         â”‚  â”‚
â”‚  â”‚  ASMD_Encryption aes_core (                                            â”‚  â”‚
â”‚  â”‚      .done          (aes_done),        // Output: completion flag      â”‚  â”‚
â”‚  â”‚      .Dout          (Dout),            // Output: 128-bit ciphertext   â”‚  â”‚
â”‚  â”‚      .plain_text_in (PT),              // Input: FROM PT BUFFER        â”‚  â”‚
â”‚  â”‚      .key_in        (KEY),             // Input: FROM KEY BUFFER       â”‚  â”‚
â”‚  â”‚      .encrypt       (aes_encrypt),     // Input: trigger signal        â”‚  â”‚
â”‚  â”‚      .clock         (clk),                                             â”‚  â”‚
â”‚  â”‚      .reset         (aes_local_reset)                                  â”‚  â”‚
â”‚  â”‚  );                                                                    â”‚  â”‚
â”‚  â”‚                                                                         â”‚  â”‚
â”‚  â”‚  Processing (inside AES core):                                         â”‚  â”‚
â”‚  â”‚  1. PT and KEY copied into internal registers                          â”‚  â”‚
â”‚  â”‚  2. Initial AddRoundKey: state â† PT âŠ• KEY                              â”‚  â”‚
â”‚  â”‚  3. 10 AES rounds (SubBytes, ShiftRows, MixColumns, AddRoundKey)      â”‚  â”‚
â”‚  â”‚  4. Each round uses on-the-fly generated round key                     â”‚  â”‚
â”‚  â”‚  5. After ~45 cycles: done=1, Dout=ciphertext                          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                    â”‚                                                           â”‚
â”‚                    â”‚ done=1 (completion signal)                                â”‚
â”‚                    â”‚ Dout[127:0] (ciphertext result)                           â”‚
â”‚                    â–¼                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ STEP 3: Store Result in RESULT Buffer                                  â”‚  â”‚
â”‚  â”‚         Code location: Line 3317                                        â”‚  â”‚
â”‚  â”‚         RESULT <= Dout;  (128-bit register assignment)                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                    â”‚                                                           â”‚
â”‚                    â–¼                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  RESULT Buffer [127:0] = Ciphertext                                     â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”                â”‚  â”‚
â”‚  â”‚  â”‚Byte15â”‚Byte14â”‚Byte13â”‚Byte12â”‚...â”‚Byte2 â”‚Byte1 â”‚Byte0 â”‚                â”‚  â”‚
â”‚  â”‚  â”‚[127: â”‚[119: â”‚[111: â”‚[103: â”‚   â”‚[23:16â”‚[15:8]â”‚[7:0] â”‚                â”‚  â”‚
â”‚  â”‚  â”‚ 120] â”‚ 112] â”‚ 104] â”‚  96] â”‚   â”‚]     â”‚]     â”‚]     â”‚                â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜                â”‚  â”‚
â”‚  â”‚    MSB                                              LSB                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                    â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ STEP 4: AUTOMATICALLY Transmit via 8-Lane Parallel SPI                 â”‚  â”‚
â”‚  â”‚         (No CPU intervention needed!)                                   â”‚  â”‚
â”‚  â”‚         Code location: Lines 3318-3353                                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                    â”‚                                                           â”‚
â”‚                    â–¼                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 8-Lane Parallel SPI Controller FSM                                      â”‚  â”‚
â”‚  â”‚ States: SPI_CS_SETUP â†’ SPI_SEND â†’ SPI_CLK_LOW â†’ ... â†’ COMPLETE         â”‚  â”‚
â”‚  â”‚                                                                         â”‚  â”‚
â”‚  â”‚ Line 3318-3322: When aes_done=1:                                        â”‚  â”‚
â”‚  â”‚   spi_byte_index <= 0;          // Reset byte counter                  â”‚  â”‚
â”‚  â”‚   spi_active     <= 1;          // Mark SPI as active                  â”‚  â”‚
â”‚  â”‚   aes_spi_cs_n   <= 0;          // Assert chip select (active low)     â”‚  â”‚
â”‚  â”‚   state          <= SPI_CS_SETUP;                                      â”‚  â”‚
â”‚  â”‚                                                                         â”‚  â”‚
â”‚  â”‚ Lines 3326-3330: SPI_CS_SETUP state:                                    â”‚  â”‚
â”‚  â”‚   aes_spi_data <= RESULT[7:0];  // First byte from RESULT buffer      â”‚  â”‚
â”‚  â”‚   aes_spi_clk  <= 1;            // Clock pulse (strobe high)          â”‚  â”‚
â”‚  â”‚                                                                         â”‚  â”‚
â”‚  â”‚ Lines 3333-3338: SPI_SEND state (repeated 15 more times):              â”‚  â”‚
â”‚  â”‚   aes_spi_data <= RESULT[(spi_byte_index*8) +: 8];  // Next byte      â”‚  â”‚
â”‚  â”‚   aes_spi_clk  <= 1;            // Clock pulse                         â”‚  â”‚
â”‚  â”‚                                                                         â”‚  â”‚
â”‚  â”‚ Lines 3341-3352: SPI_CLK_LOW state:                                     â”‚  â”‚
â”‚  â”‚   aes_spi_clk <= 0;             // Complete clock cycle                â”‚  â”‚
â”‚  â”‚   spi_byte_index++;             // Move to next byte                   â”‚  â”‚
â”‚  â”‚   if (spi_byte_index < 15) loop to SPI_SEND                            â”‚  â”‚
â”‚  â”‚   else: spi_active <= 0; aes_spi_cs_n <= 1; (transmission complete)   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                    â”‚                                                           â”‚
â”‚                    â–¼                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚        8-Lane Parallel SPI Output Pins                                  â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚  aes_spi_data[7:0] - 8 GPIO pins (PARALLEL data output)           â”‚ â”‚  â”‚
â”‚  â”‚  â”‚    Pin 7: Bit 7 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚    Pin 6: Bit 6 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚    Pin 5: Bit 5 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚    Pin 4: Bit 4 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚    â”‚      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚    Pin 3: Bit 3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚    â”‚    â”‚      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚    Pin 2: Bit 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚    â”‚    â”‚    â”‚      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚    Pin 1: Bit 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚    Pin 0: Bit 0 â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚                         â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚                         â–¼    â–¼    â–¼    â–¼    â–¼    â–¼    â–¼    â–¼      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚                       [D7][D6][D5][D4][D3][D2][D1][D0]             â”‚ â”‚  â”‚
â”‚  â”‚  â”‚                                                                     â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  aes_spi_clk - Clock strobe (pulses 16 times, once per byte)      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  aes_spi_cs_n - Chip select (active low during transmission)      â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  aes_spi_active - Status indicator (high during transmission)     â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                    â”‚                                                           â”‚
â”‚                    â”‚ (Parallel to SPI, CPU can also read back)                 â”‚
â”‚                    â–¼                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ STEP 5 (Optional): CPU Reads Back Result                               â”‚  â”‚
â”‚  â”‚         Using AES_READ instruction                                      â”‚  â”‚
â”‚  â”‚         Code location: Lines 3288-3298                                  â”‚  â”‚
â”‚  â”‚                                                                         â”‚  â”‚
â”‚  â”‚ Executed 4 times (word_index = 0, 1, 2, 3):                            â”‚  â”‚
â”‚  â”‚   case (word_index)                                                     â”‚  â”‚
â”‚  â”‚     2'd0: pcpi_rd <= RESULT[31:0];    // Read first word from buffer   â”‚  â”‚
â”‚  â”‚     2'd1: pcpi_rd <= RESULT[63:32];   // Read second word              â”‚  â”‚
â”‚  â”‚     2'd2: pcpi_rd <= RESULT[95:64];   // Read third word               â”‚  â”‚
â”‚  â”‚     2'd3: pcpi_rd <= RESULT[127:96];  // Read fourth word              â”‚  â”‚
â”‚  â”‚   endcase                                                               â”‚  â”‚
â”‚  â”‚                                                                         â”‚  â”‚
â”‚  â”‚ Result: CPU registers now contain ciphertext words                      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”„ Key Points About Buffer Usage

### Before Encryption:
1. **PT Buffer** stores plaintext (loaded word-by-word from CPU)
2. **KEY Buffer** stores encryption key (loaded word-by-word from CPU)
3. Both buffers must be fully loaded before encryption starts

### During Encryption:
- AES core reads from PT and KEY buffers
- Internal AES registers hold intermediate states
- Round key register updates each round (on-the-fly key expansion)

### After Encryption:
- **RESULT Buffer** stores final ciphertext
- RESULT buffer serves dual purpose:
  1. Source for SPI transmission (automatic)
  2. Source for CPU read-back (via AES_READ instruction)

---

## ğŸš€ What is "8-Lane Parallel SPI"?

### Traditional Serial SPI (1 bit per clock):
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Serial SPI - ONE bit transmitted per clock cycle            â”‚
â”‚                                                              â”‚
â”‚  Clock:  _â•±â€¾â•²_â•±â€¾â•²_â•±â€¾â•²_â•±â€¾â•²_â•±â€¾â•²_â•±â€¾â•²_â•±â€¾â•²_â•±â€¾â•²_  ... 128 pulses  â”‚
â”‚  MOSI:   â”€â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”€                     â”‚
â”‚           D0â”‚D1â”‚D2â”‚D3â”‚D4â”‚D5â”‚D6â”‚D7â”‚ ...  D127                â”‚
â”‚           â””â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”€                     â”‚
â”‚                                                              â”‚
â”‚  Transmission time: 128 clock cycles for 128 bits            â”‚
â”‚                     = 1280 ns @ 100 MHz                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Your 8-Lane Parallel SPI (8 bits per clock):
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  8-Lane Parallel SPI - EIGHT bits per clock cycle           â”‚
â”‚                                                              â”‚
â”‚  Clock:  _â•±â€¾â•²_â•±â€¾â•²_â•±â€¾â•²_â•±â€¾â•²_â•±â€¾â•²_  ... 16 pulses only!         â”‚
â”‚                                                              â”‚
â”‚  Data Lane 0: â”€â”€[Byte0]â”€[Byte1]â”€[Byte2]â”€ ... â”€[Byte15]â”€â”€   â”‚
â”‚  Data Lane 1: â”€â”€[Byte0]â”€[Byte1]â”€[Byte2]â”€ ... â”€[Byte15]â”€â”€   â”‚
â”‚  Data Lane 2: â”€â”€[Byte0]â”€[Byte1]â”€[Byte2]â”€ ... â”€[Byte15]â”€â”€   â”‚
â”‚  Data Lane 3: â”€â”€[Byte0]â”€[Byte1]â”€[Byte2]â”€ ... â”€[Byte15]â”€â”€   â”‚
â”‚  Data Lane 4: â”€â”€[Byte0]â”€[Byte1]â”€[Byte2]â”€ ... â”€[Byte15]â”€â”€   â”‚
â”‚  Data Lane 5: â”€â”€[Byte0]â”€[Byte1]â”€[Byte2]â”€ ... â”€[Byte15]â”€â”€   â”‚
â”‚  Data Lane 6: â”€â”€[Byte0]â”€[Byte1]â”€[Byte2]â”€ ... â”€[Byte15]â”€â”€   â”‚
â”‚  Data Lane 7: â”€â”€[Byte0]â”€[Byte1]â”€[Byte2]â”€ ... â”€[Byte15]â”€â”€   â”‚
â”‚                  â–²       â–²       â–²             â–²            â”‚
â”‚                  â”‚       â”‚       â”‚             â”‚            â”‚
â”‚                  Clock 1 Clock 2 Clock 3   Clock 16         â”‚
â”‚                                                              â”‚
â”‚  8 bits captured on EACH clock pulse!                       â”‚
â”‚  Transmission time: 16 clock cycles for 128 bits            â”‚
â”‚                     = 160 ns @ 100 MHz                       â”‚
â”‚                     (8Ã— FASTER than serial!)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Physical Connection:

**Serial SPI (Traditional):**
```
FPGA                          Receiver
â”Œâ”€â”€â”€â”€â”€â”€â”                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      â”‚â”€â”€MOSI (1 wire)â”€â”€â”€â”€â”€â–¶â”‚        â”‚
â”‚      â”‚â”€â”€SCLKâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚        â”‚
â”‚      â”‚â”€â”€CS_Nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚        â”‚
â””â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   3 wires total
```

**8-Lane Parallel SPI (Your Design):**
```
FPGA                                 Receiver
â”Œâ”€â”€â”€â”€â”€â”€â”                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      â”‚â”€â”€Data[0] (wire 0)â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚        â”‚
â”‚      â”‚â”€â”€Data[1] (wire 1)â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚        â”‚
â”‚      â”‚â”€â”€Data[2] (wire 2)â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚        â”‚
â”‚      â”‚â”€â”€Data[3] (wire 3)â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚        â”‚
â”‚      â”‚â”€â”€Data[4] (wire 4)â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ 8-bit  â”‚
â”‚      â”‚â”€â”€Data[5] (wire 5)â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Latch  â”‚
â”‚      â”‚â”€â”€Data[6] (wire 6)â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚        â”‚
â”‚      â”‚â”€â”€Data[7] (wire 7)â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚        â”‚
â”‚      â”‚â”€â”€CLK (strobe)â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚        â”‚
â”‚      â”‚â”€â”€CS_Nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚        â”‚
â”‚      â”‚â”€â”€ACTIVEâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚        â”‚
â””â”€â”€â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   11 wires total (8 data + 3 control)

Receiver samples all 8 data lines on rising edge of CLK
```

---

## ğŸ“ Code Walkthrough: Byte-by-Byte Transmission

```verilog
// From picorv32.v, lines 3333-3346
SPI_SEND: begin
    // Extract one byte from RESULT buffer based on byte index
    aes_spi_data <= RESULT[(spi_byte_index*8) +: 8];
    //                      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    //                             â”‚
    //              This selects 8 bits from RESULT:
    //              - When spi_byte_index=0:  RESULT[7:0]   (Byte 0)
    //              - When spi_byte_index=1:  RESULT[15:8]  (Byte 1)
    //              - When spi_byte_index=2:  RESULT[23:16] (Byte 2)
    //              - ...
    //              - When spi_byte_index=15: RESULT[127:120] (Byte 15)

    aes_spi_clk  <= 1;  // Strobe high (receiver captures data on rising edge)
    state        <= SPI_CLK_LOW;
end

SPI_CLK_LOW: begin
    aes_spi_clk <= 0;  // Complete the clock cycle
    if (spi_byte_index < 15) begin
        spi_byte_index <= spi_byte_index + 1'b1;  // Next byte
        state          <= SPI_SEND;
    end else begin
        // All 16 bytes sent, finish transmission
        spi_active   <= 0;
        aes_spi_cs_n <= 1;  // Deassert chip select
        state        <= COMPLETE;
    end
end
```

---

## ğŸ“Š Timeline Example (@ 100 MHz = 10 ns per cycle)

```
Cycle    State            Action
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  0      IDLE             CPU loads PT word 0
  1      EXECUTE          PT[31:0] â† data
  2      IDLE             CPU loads PT word 1
  3      EXECUTE          PT[63:32] â† data
  4      IDLE             CPU loads PT word 2
  5      EXECUTE          PT[95:64] â† data
  6      IDLE             CPU loads PT word 3
  7      EXECUTE          PT[127:96] â† data

  8-15   [Similar for KEY loading]

  16     IDLE             CPU executes AES_START
  17     START_AES        aes_encrypt=1
  18-62  WAIT_AES         AES core processing (~45 cycles)

  63     WAIT_AES         aes_done=1, RESULTâ†Dout
  64     SPI_CS_SETUP     cs_n=0, data=Byte0, clk=1
  65     SPI_CLK_LOW      clk=0, index++
  66     SPI_SEND         data=Byte1, clk=1
  67     SPI_CLK_LOW      clk=0, index++
  68     SPI_SEND         data=Byte2, clk=1
  69     SPI_CLK_LOW      clk=0, index++
  ...
  94     SPI_SEND         data=Byte15, clk=1
  95     SPI_CLK_LOW      clk=0, cs_n=1, done
  96     COMPLETE         Signal CPU completion
  97     IDLE             Ready for next operation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total: ~97 cycles = 970 ns for complete operation
  (8 PT loads + 8 KEY loads + 1 start + 45 AES + 32 SPI + overhead)
```

---

## ğŸ¯ Summary

### Buffers:
1. **PT** - Holds plaintext BEFORE encryption (loaded from CPU)
2. **KEY** - Holds encryption key BEFORE encryption (loaded from CPU)
3. **RESULT** - Holds ciphertext AFTER encryption (for SPI and CPU read-back)

### Data Flow:
```
CPU Registers â†’ PT/KEY Buffers â†’ AES Core â†’ RESULT Buffer â†’ 8-Lane SPI Output
                                                          â””â†’ CPU Read-back
```

### 8-Lane SPI:
- **NOT** 8 separate SPI channels
- **ONE** SPI interface with 8 data lines transmitting in parallel
- 8 bits = 1 byte transmitted per clock pulse
- 16 pulses transmit entire 128-bit ciphertext
- **8Ã— faster** than traditional serial SPI

### Why Buffers Are Needed:
1. **CPU operates on 32-bit words**, AES needs **128-bit blocks**
2. Buffers **accumulate 4 words** into one 128-bit block
3. AES core can **process full 128-bit block atomically**
4. RESULT buffer **decouples** AES completion from SPI transmission
5. Allows **CPU to read back** result while/after SPI transmission

---

**Key Takeaway:** Buffers are essential intermediate storage that bridge the 32-bit CPU world with the 128-bit AES world!
