`timescale 1 ns / 1 ps

/***************************************************************
 * Testbench for PicoRV32 AES with BRAM Memory
 *
 * This version uses actual BRAM-based memory (synthesizable)
 * instead of testbench memory simulation.
 *
 * Memory is initialized from program.hex file generated by
 * generate_program_hex.py script.
 ***************************************************************/

module tb_picorv32_aes_bram;

    //=========================================================
    // Parameters
    //=========================================================
    parameter CLK_PERIOD = 10;          // 100 MHz clock
    parameter TIMEOUT_CYCLES = 50000;   // Max cycles before timeout

    //=========================================================
    // Clock and Reset
    //=========================================================
    reg clk = 1;
    reg resetn = 0;
    wire trap;

    always #(CLK_PERIOD/2) clk = ~clk;

    //=========================================================
    // VCD Dump
    //=========================================================
    initial begin
        $dumpfile("tb_picorv32_aes_bram.vcd");
        $dumpvars(0, tb_picorv32_aes_bram);
    end

    //=========================================================
    // 8-Lane Parallel SPI Interface
    //=========================================================
    wire [7:0] aes_spi_data;
    wire       aes_spi_clk;
    wire       aes_spi_cs_n;
    wire       aes_spi_active;

    //=========================================================
    // Memory Interface (connects CPU to BRAM)
    //=========================================================
    wire        mem_valid;
    wire        mem_instr;
    wire        mem_ready;
    wire [31:0] mem_addr;
    wire [31:0] mem_wdata;
    wire [3:0]  mem_wstrb;
    wire [31:0] mem_rdata;

    //=========================================================
    // PicoRV32 CPU Instance
    //=========================================================
    picorv32 #(
        .ENABLE_COUNTERS(1),
        .ENABLE_REGS_16_31(1),
        .ENABLE_REGS_DUALPORT(1),
        .LATCHED_MEM_RDATA(0),
        .TWO_STAGE_SHIFT(1),
        .TWO_CYCLE_COMPARE(0),
        .TWO_CYCLE_ALU(0),
        .CATCH_MISALIGN(1),
        .CATCH_ILLINSN(1),
        .ENABLE_PCPI(1),
        .ENABLE_MUL(1),
        .ENABLE_DIV(1),
        .ENABLE_FAST_MUL(1),
        .ENABLE_IRQ(0),
        .ENABLE_IRQ_QREGS(0),
        // **Enable AES encryption co-processor**
        .ENABLE_AES(1),
        .ENABLE_AES_DEC(0)
    ) cpu (
        .clk         (clk),
        .resetn      (resetn),
        .trap        (trap),

        // Memory Interface
        .mem_valid   (mem_valid),
        .mem_instr   (mem_instr),
        .mem_ready   (mem_ready),
        .mem_addr    (mem_addr),
        .mem_wdata   (mem_wdata),
        .mem_wstrb   (mem_wstrb),
        .mem_rdata   (mem_rdata),

        // 8-Lane Parallel SPI Interface
        .aes_spi_data   (aes_spi_data),
        .aes_spi_clk    (aes_spi_clk),
        .aes_spi_cs_n   (aes_spi_cs_n),
        .aes_spi_active (aes_spi_active)
    );

    //=========================================================
    // BRAM Memory Instance
    //=========================================================
    bram_memory #(
        .MEM_SIZE_WORDS(2048),           // 8 KB memory
        .MEM_INIT_FILE("program.hex")    // Load from hex file
    ) mem (
        .clk        (clk),
        .resetn     (resetn),
        .mem_valid  (mem_valid),
        .mem_instr  (mem_instr),
        .mem_ready  (mem_ready),
        .mem_addr   (mem_addr),
        .mem_wdata  (mem_wdata),
        .mem_wstrb  (mem_wstrb),
        .mem_rdata  (mem_rdata)
    );

    //=========================================================
    // Test Control
    //=========================================================
    reg [31:0] cycle_count = 0;
    reg [127:0] expected_ciphertext = 128'h69c4e0d86a7b0430d8cdb78070b4c55a;

    // 8-Lane SPI Capture
    reg [7:0]  spi_received_bytes [0:15];
    reg [4:0]  spi_byte_count = 0;
    reg        spi_prev_clk = 0;
    reg        spi_prev_cs_n = 1;
    reg        spi_transfer_complete = 0;
    reg [127:0] received_ciphertext;

    //=========================================================
    // Cycle Counter
    //=========================================================
    always @(posedge clk) begin
        if (resetn)
            cycle_count <= cycle_count + 1;
    end

    //=========================================================
    // 8-Lane Parallel SPI Capture
    //=========================================================
    always @(posedge clk) begin
        spi_prev_clk <= aes_spi_clk;
        spi_prev_cs_n <= aes_spi_cs_n;

        // Start of transfer
        if (!aes_spi_cs_n && spi_prev_cs_n) begin
            spi_byte_count <= 0;
            spi_transfer_complete <= 0;
            $display("[Cycle %0d] SPI Transfer Started", cycle_count);
        end

        // End of transfer
        if (aes_spi_cs_n && !spi_prev_cs_n) begin
            spi_transfer_complete <= 1;
            $display("[Cycle %0d] SPI Transfer Complete (%0d bytes)", cycle_count, spi_byte_count);

            // Reconstruct ciphertext
            received_ciphertext = {
                spi_received_bytes[15], spi_received_bytes[14],
                spi_received_bytes[13], spi_received_bytes[12],
                spi_received_bytes[11], spi_received_bytes[10],
                spi_received_bytes[9],  spi_received_bytes[8],
                spi_received_bytes[7],  spi_received_bytes[6],
                spi_received_bytes[5],  spi_received_bytes[4],
                spi_received_bytes[3],  spi_received_bytes[2],
                spi_received_bytes[1],  spi_received_bytes[0]
            };
        end

        // Capture data on rising edge
        if (!aes_spi_cs_n && aes_spi_clk && !spi_prev_clk) begin
            spi_received_bytes[spi_byte_count] <= aes_spi_data;
            $display("  SPI Byte[%2d] = 0x%02x", spi_byte_count, aes_spi_data);
            spi_byte_count <= spi_byte_count + 1;
        end
    end

    //=========================================================
    // Trap Monitor
    //=========================================================
    always @(posedge clk) begin
        if (trap) begin
            $display("");
            $display("!!! TRAP detected at cycle %0d !!!", cycle_count);
            $display("!!! This indicates an illegal instruction or error !!!");
            $display("");
            #100;
            $finish;
        end
    end

    //=========================================================
    // Main Test Sequence
    //=========================================================
    initial begin : main_test
        integer i;

        $display("================================================================");
        $display("  PicoRV32 AES with BRAM Memory Test");
        $display("================================================================");
        $display("");
        $display("Configuration:");
        $display("  - Memory: BRAM-based (synthesizable)");
        $display("  - Init File: program.hex");
        $display("  - Clock: %0d MHz", 1000/CLK_PERIOD);
        $display("");

        // Initialize SPI capture
        for (i = 0; i < 16; i = i + 1)
            spi_received_bytes[i] = 8'h00;

        // Reset sequence
        repeat (20) @(posedge clk);
        resetn <= 1;
        $display("[Cycle 0] Reset released - CPU starting");
        $display("");

        // Wait for SPI transfer completion
        fork
            begin : wait_spi
                wait(spi_transfer_complete == 1);
                $display("");
                $display("================================================================");
                $display("  SPI Transfer Complete - Verifying Results");
                $display("================================================================");

                // Give time for memory writes
                repeat (200) @(posedge clk);

                // Display results
                $display("");
                $display("Received Ciphertext: 0x%032x", received_ciphertext);
                $display("Expected Ciphertext: 0x%032x", expected_ciphertext);

                if (received_ciphertext == expected_ciphertext) begin
                    $display("");
                    $display("================================================================");
                    $display("  *** TEST PASSED *** ");
                    $display("================================================================");
                    $display("");
                end else begin
                    $display("");
                    $display("================================================================");
                    $display("  *** TEST FAILED ***");
                    $display("================================================================");
                    $display("");
                end

                #1000;
                $finish;
            end

            begin : timeout
                repeat (TIMEOUT_CYCLES) @(posedge clk);
                $display("");
                $display("================================================================");
                $display("  *** TIMEOUT - Test did not complete ***");
                $display("================================================================");
                $display("  Cycles elapsed: %0d", TIMEOUT_CYCLES);
                $display("");
                $finish;
            end
        join
    end

endmodule
