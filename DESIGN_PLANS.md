# Bidirectional Secure Communication Design Plan

This document outlines the design for bidirectional encrypted communication between two PicoRV32-based devices using AES-128 and 8-lane parallel SPI.

---

## Table of Contents

1. [Current System (Sender/Master)](#current-system)
2. [Receiver Side Design](#receiver-side-design)
3. [Bidirectional Architecture (Option B)](#bidirectional-architecture)
4. [Signal Definitions](#signal-definitions)
5. [Hardware Modules](#hardware-modules)
6. [Memory Map](#memory-map)
7. [Communication Flow](#communication-flow)
8. [Software Architecture](#software-architecture)
9. [AES Decryption Instructions](#aes-decryption-instructions)
10. [Timing Analysis](#timing-analysis)
11. [Implementation Phases](#implementation-phases)
12. [FPGA Implementation](#fpga-implementation)
13. [Security Considerations](#security-considerations)

---

## Current System

What we have accomplished:
- PicoRV32 CPU with AES-128 encryption co-processor
- When encryption completes, ciphertext auto-transmits via 8-lane parallel SPI
- Sender is SPI Master (generates clock, controls transfers)

```
┌─────────────────────────────────────────────┐
│  DEVICE A (Sender/SPI Master)               │
│                                             │
│  CPU → Load plaintext + key                 │
│         ↓                                   │
│  AES Co-processor encrypts                  │
│         ↓                                   │
│  8-lane parallel SPI transmits ciphertext   │
│         ↓                                   │
│  [SPI_CLK, SPI_DATA[7:0], CS_n] ──────────→ │
└─────────────────────────────────────────────┘
```

---

## Receiver Side Design

The receiver needs an SPI Slave interface:

```
┌─────────────────────────────────────────────┐
│  DEVICE B (Receiver/SPI Slave)              │
│                                             │
│  ←────── [SPI_CLK, SPI_DATA[7:0], CS_n]     │
│         ↓                                   │
│  SPI Slave captures bytes on clock edges    │
│         ↓                                   │
│  128-bit shift register fills up            │
│         ↓                                   │
│  Interrupt/flag signals CPU "data ready"    │
│         ↓                                   │
│  CPU reads ciphertext from buffer           │
│         ↓                                   │
│  AES Decryption co-processor decrypts       │
│         ↓                                   │
│  CPU reads plaintext                        │
└─────────────────────────────────────────────┘
```

### Key Points

- **Passive Listening**: SPI slave hardware monitors lines continuously
- **CS_n**: When master pulls LOW, transfer starts
- **SPI_CLK**: Slave samples data on rising edges
- **No CPU polling needed**: Hardware handles reception, interrupts CPU when done

---

## Bidirectional Architecture

Option B: Dual SPI buses - each device has both master and slave.

```
╔═══════════════════════════════════════════════════════════════════════════════╗
║                        BIDIRECTIONAL SECURE LINK                               ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                                ║
║   ┌─────────────────────────┐              ┌─────────────────────────┐        ║
║   │      DEVICE A           │   CHANNEL 1  │      DEVICE B           │        ║
║   │                         │   (A → B)    │                         │        ║
║   │  ┌─────────────────┐    │              │    ┌─────────────────┐  │        ║
║   │  │ SPI MASTER (TX) │════╬══════════════╬═══>│ SPI SLAVE (RX)  │  │        ║
║   │  └─────────────────┘    │  8-lane data │    └─────────────────┘  │        ║
║   │                         │   + clk + cs │                         │        ║
║   │  ┌─────────────────┐    │              │    ┌─────────────────┐  │        ║
║   │  │ SPI SLAVE (RX)  │<═══╬══════════════╬════│ SPI MASTER (TX) │  │        ║
║   │  └─────────────────┘    │   CHANNEL 2  │    └─────────────────┘  │        ║
║   │                         │   (B → A)    │                         │        ║
║   └─────────────────────────┘              └─────────────────────────┘        ║
║                                                                                ║
╚═══════════════════════════════════════════════════════════════════════════════╝
```

### Advantages
- Either device can initiate communication at any time
- No arbitration needed (separate buses)
- Identical hardware on both devices (simpler manufacturing)

---

## Signal Definitions

### Channel 1: Device A → Device B

| Signal         | Width | Direction | Description                    |
|----------------|-------|-----------|--------------------------------|
| `ch1_spi_clk`  | 1     | A → B     | Clock generated by A's master  |
| `ch1_spi_data` | 8     | A → B     | 8-lane parallel data           |
| `ch1_spi_cs_n` | 1     | A → B     | Chip select (active low)       |

### Channel 2: Device B → Device A

| Signal         | Width | Direction | Description                    |
|----------------|-------|-----------|--------------------------------|
| `ch2_spi_clk`  | 1     | B → A     | Clock generated by B's master  |
| `ch2_spi_data` | 8     | B → A     | 8-lane parallel data           |
| `ch2_spi_cs_n` | 1     | B → A     | Chip select (active low)       |

### Total Pin Count Per Device

| Function           | Pins |
|--------------------|------|
| TX Master (output) | 10 (8 data + clk + cs) |
| RX Slave (input)   | 10 (8 data + clk + cs) |
| **Total**          | **20 pins** |

---

## Hardware Modules

### Single Device Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            SINGLE DEVICE ARCHITECTURE                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │                         PicoRV32 CPU                                  │   │
│  │                    (RV32IMC + PCPI Interface)                         │   │
│  └───────────┬──────────────────┬──────────────────┬────────────────────┘   │
│              │ PCPI             │ PCPI             │ Memory Bus             │
│              ▼                  ▼                  ▼                        │
│  ┌───────────────────┐ ┌───────────────────┐ ┌──────────────────────────┐   │
│  │ AES ENCRYPT       │ │ AES DECRYPT       │ │ MEMORY-MAPPED REGISTERS  │   │
│  │ Co-processor      │ │ Co-processor      │ │                          │   │
│  │                   │ │                   │ │ - SPI Slave RX Buffer    │   │
│  │ Input: 128b PT+Key│ │ Input: 128b CT+Key│ │ - SPI Slave Status       │   │
│  │ Output: 128b CT   │ │ Output: 128b PT   │ │ - Interrupt Control      │   │
│  └─────────┬─────────┘ └─────────▲─────────┘ └────────────▲─────────────┘   │
│            │                     │                        │                  │
│            │ Auto-trigger        │ CPU loads              │ CPU reads        │
│            ▼                     │ ciphertext             │ received data    │
│  ┌───────────────────┐ ┌─────────┴─────────┐                                │
│  │ SPI MASTER (TX)   │ │ SPI SLAVE (RX)    │◄────── External SPI Input      │
│  │                   │ │                   │                                 │
│  │ 8-lane parallel   │ │ 8-lane parallel   │                                 │
│  │ Sends ciphertext  │ │ Receives cipher   │                                 │
│  │ after encryption  │ │ Buffers 128 bits  │                                 │
│  │ completes         │ │ Raises IRQ        │                                 │
│  └─────────┬─────────┘ └───────────────────┘                                │
│            │                                                                 │
│            ▼                                                                 │
│     External SPI Output                                                      │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Module 1: SPI Master (TX) - Already Exists

Located in `picorv32.v`. Functionality:
- Waits for AES encryption completion
- Automatically transmits 128-bit ciphertext
- 8 lanes, 16 clock pulses, 32 system cycles

### Module 2: SPI Slave (RX) - New Module

**File**: `spi_slave_8lane.v`

#### Ports

| Signal        | Width | Dir | Description                              |
|---------------|-------|-----|------------------------------------------|
| `clk`         | 1     | in  | System clock                             |
| `resetn`      | 1     | in  | Active-low reset                         |
| `spi_clk_in`  | 1     | in  | External SPI clock from remote master    |
| `spi_data_in` | 8     | in  | 8-lane parallel data input               |
| `spi_cs_n_in` | 1     | in  | Chip select from remote master           |
| `rx_data`     | 128   | out | Received ciphertext buffer               |
| `rx_valid`    | 1     | out | Pulse high for 1 cycle when complete     |
| `rx_busy`     | 1     | out | High during active reception             |
| `irq_rx`      | 1     | out | Directly connects to CPU interrupt       |

#### State Machine

```
                    ┌──────────────┐
                    │    IDLE      │
                    │  (cs_n = 1)  │
                    └──────┬───────┘
                           │ cs_n falls to 0
                           ▼
                    ┌──────────────┐
                    │  RECEIVING   │
                    │              │
                    │ On each rising│
                    │ edge of spi_clk│
                    │ shift in 8 bits│
                    │ increment counter│
                    └──────┬───────┘
                           │ counter == 16
                           ▼
                    ┌──────────────┐
                    │  COMPLETE    │
                    │              │
                    │ Assert rx_valid│
                    │ Assert IRQ    │
                    │ Latch 128-bit │
                    │ buffer        │
                    └──────┬───────┘
                           │ cs_n rises to 1
                           ▼
                    ┌──────────────┐
                    │    IDLE      │
                    └──────────────┘
```

#### Clock Domain Crossing

External `spi_clk_in` is asynchronous to system `clk`. Need synchronizer:

```
spi_clk_in ──►[FF]──►[FF]──► spi_clk_sync ──► edge_detect ──► sample_pulse
              sync1   sync2
```

### Module 3: RX Buffer & Memory-Mapped Interface

**File**: `spi_rx_buffer.v`

Allows CPU to read received ciphertext via memory-mapped registers.

---

## Memory Map

### SPI Slave RX Registers

| Address       | Register     | R/W | Description                          |
|---------------|--------------|-----|--------------------------------------|
| `0x3000_0000` | `RX_STATUS`  | R   | Bit 0: rx_valid (data ready)         |
| `0x3000_0004` | `RX_DATA_0`  | R   | Ciphertext bytes [31:0]              |
| `0x3000_0008` | `RX_DATA_1`  | R   | Ciphertext bytes [63:32]             |
| `0x3000_000C` | `RX_DATA_2`  | R   | Ciphertext bytes [95:64]             |
| `0x3000_0010` | `RX_DATA_3`  | R   | Ciphertext bytes [127:96]            |
| `0x3000_0014` | `RX_CLEAR`   | W   | Write any value to clear rx_valid    |
| `0x3000_0018` | `IRQ_ENABLE` | R/W | Bit 0: Enable RX complete interrupt  |

### Behavior

- `RX_STATUS` bit 0 goes high when 128 bits received
- CPU reads `RX_DATA_0..3` to get ciphertext
- CPU writes to `RX_CLEAR` to acknowledge and allow next reception
- If `IRQ_ENABLE` is set, `irq_rx_complete` triggers CPU interrupt

---

## Communication Flow

### Scenario: Device A sends encrypted message to Device B

```
TIME    DEVICE A                              DEVICE B
────────────────────────────────────────────────────────────────────────
 T0     CPU loads plaintext into              [Idle - SPI Slave listening]
        AES encrypt co-processor

 T1     CPU loads key

 T2     CPU issues AES_START

 T3     [AES encrypting - 11 rounds]
        ...

 T4     AES complete, ciphertext ready
        SPI Master auto-triggers

 T5     CS_n goes LOW ─────────────────────►  SPI Slave sees CS_n fall
        CLK pulse + 8 bits ────────────────►  Slave samples byte 0

 T6     CLK pulse + 8 bits ────────────────►  Slave samples byte 1
        ...

 T20    CLK pulse + 8 bits ────────────────►  Slave samples byte 15
        CS_n goes HIGH ────────────────────►
                                              RX complete, IRQ fires

 T21    [Done transmitting]                   CPU interrupted
                                              ISR: set "data ready" flag

 T22                                          Main loop sees flag
                                              CPU reads RX_DATA_0..3
                                              CPU clears RX_STATUS

 T23                                          CPU loads ciphertext into
                                              AES decrypt co-processor
                                              CPU loads key
                                              CPU issues AES_DEC_START

 T24                                          [AES decrypting]
                                              ...

 T25                                          AES complete
                                              CPU reads plaintext
                                              MESSAGE RECEIVED!
────────────────────────────────────────────────────────────────────────
```

---

## Software Architecture

### Interrupt Service Routine (ISR)

```c
ISR_SPI_RX:
    1. Read RX_STATUS to confirm it's RX interrupt
    2. Set global flag: g_rx_data_ready = 1
    3. Write to RX_CLEAR to acknowledge
    4. Return from interrupt
```

### Main Loop (Receiver Side)

```c
MAIN_LOOP:
    1. Check g_rx_data_ready flag
    2. If not set, do other work, goto 1
    3. Clear g_rx_data_ready
    4. Read RX_DATA_0, RX_DATA_1, RX_DATA_2, RX_DATA_3
    5. Load into AES decrypt co-processor (4 writes)
    6. Load key (4 writes) - key pre-shared or derived
    7. Issue AES_DEC_START
    8. Poll AES_DEC_STATUS until done
    9. Read decrypted plaintext (4 reads)
    10. Process plaintext (application-specific)
    11. Goto 1
```

### Transmit Flow (Either Device)

```c
SEND_ENCRYPTED_MESSAGE:
    1. Load plaintext into AES encrypt (4 writes)
    2. Load key (4 writes)
    3. Issue AES_START
    4. Poll AES_STATUS until done
    5. [Hardware auto-transmits via SPI Master]
    6. Optionally poll SPI_TX_STATUS for completion
    7. Return
```

---

## AES Decryption Instructions

Mirror the encryption instructions (opcode `0x0B`, funct3=`0x0`):

| Instruction      | funct7  | Description              |
|------------------|---------|--------------------------|
| `AES_DEC_LOAD_CT`| 0110000 | Load ciphertext word     |
| `AES_DEC_LOAD_KEY`| 0110001| Load key word            |
| `AES_DEC_START`  | 0110010 | Start decryption         |
| `AES_DEC_READ`   | 0110011 | Read plaintext word      |
| `AES_DEC_STATUS` | 0110100 | Check completion         |

Decryption modules exist in `Aes-Code/Aes-Decryption/`. Need PCPI wrapper integration.

---

## Timing Analysis

### Transmission Time (at 50 MHz)

| Parameter         | Value                              |
|-------------------|------------------------------------|
| System clock      | 50 MHz (20 ns period)              |
| SPI clock         | 1 pulse per 2 system cycles = 25 MHz |
| Bytes to send     | 16                                 |
| Total transmission| 16 × 2 = 32 system cycles = 640 ns |

### Total Latency (One Direction)

```
AES Encrypt:    ~44 cycles  =   880 ns
SPI Transfer:    32 cycles  =   640 ns
AES Decrypt:    ~44 cycles  =   880 ns
Software OH:   ~100 cycles  = 2,000 ns
─────────────────────────────────────────
TOTAL:         ~220 cycles  ≈ 4.4 µs
```

---

## Implementation Phases

### Phase 1: SPI Slave Receiver

1. Design `spi_slave_8lane.v` with clock synchronization
2. Create simple testbench with direct signal driving
3. Verify 16-byte reception and IRQ

### Phase 2: Memory-Mapped Integration

1. Add RX buffer registers to memory map
2. Integrate into picorv32.v (or wrapper)
3. Test CPU can read received data via firmware

### Phase 3: AES Decryption Integration

1. Create PCPI wrapper for existing decryption modules
2. Add to picorv32.v alongside encryption co-processor
3. Test decryption with known vectors

### Phase 4: Full Bidirectional Test

1. Create testbench with two complete devices
2. Wire Channel 1 (A→B) and Channel 2 (B→A)
3. Run full send-receive-decrypt scenario

### Phase 5: FPGA Validation

1. Create top-level for 2-device system (or use 2 FPGAs)
2. Map pins appropriately
3. Real hardware test

---

## FPGA Implementation

### Option A: Two Separate FPGAs (Real Demo)

```
┌─────────────┐    20 wires     ┌─────────────┐
│   FPGA 1    │◄───────────────►│   FPGA 2    │
│  (Device A) │  Channel 1 + 2  │  (Device B) │
└─────────────┘                 └─────────────┘
```

- Each FPGA runs identical bitstream
- Connect 10 pins for Channel 1, 10 pins for Channel 2

### Option B: Single FPGA with Loopback (Testing)

```
┌─────────────────────────────────────┐
│              SINGLE FPGA            │
│  ┌──────────┐      ┌──────────┐     │
│  │ Device A │◄────►│ Device B │     │
│  └──────────┘      └──────────┘     │
│       Internal wiring only          │
└─────────────────────────────────────┘
```

- Both devices instantiated in same FPGA
- Channels connected internally

### Top-Level Structure

```
fpga_top.v
├── Device A instance (picorv32 + AES + SPI master + SPI slave)
├── Device B instance (picorv32 + AES + SPI master + SPI slave)
├── Channel 1 wiring (A.master → B.slave)
├── Channel 2 wiring (B.master → A.slave)
├── Clock input (external oscillator)
├── Reset button
└── Debug outputs (LEDs, UART)
```

### Pin Assignments (Basys3 Example)

| Signal    | Pin | Purpose              |
|-----------|-----|----------------------|
| `clk`     | W5  | 100 MHz oscillator   |
| `rst_n`   | U18 | Button (active low)  |
| `led[0]`  | U16 | Device A TX active   |
| `led[1]`  | E19 | Device B RX complete |
| `led[2]`  | U19 | Device B TX active   |
| `led[3]`  | V19 | Device A RX complete |

### Resource Estimate (Artix-7 35T)

| Component          | LUTs   | FFs    | BRAM |
|--------------------|--------|--------|------|
| PicoRV32 (×2)      | ~3000  | ~1500  | 2    |
| AES Encrypt (×2)   | ~4000  | ~2000  | 0    |
| AES Decrypt (×2)   | ~4000  | ~2000  | 0    |
| SPI Master (×2)    | ~200   | ~200   | 0    |
| SPI Slave (×2)     | ~200   | ~200   | 0    |
| **Total**          | ~11,400| ~5,900 | 2    |
| **Artix-7 35T**    | 20,800 | 41,600 | 50   |
| **Utilization**    | ~55%   | ~14%   | 4%   |

### Synthesis Flow (Vivado)

```bash
# 1. Create project
vivado -mode tcl
create_project aes_soc ./aes_soc -part xc7a35tcpg236-1

# 2. Add sources
add_files {picorv32.v fpga_top.v Aes-Code/*.v spi_slave_8lane.v}

# 3. Add constraints
add_files -fileset constrs_1 basys3_aes.xdc

# 4. Run synthesis + implementation
launch_runs synth_1 -jobs 4
launch_runs impl_1 -to_step write_bitstream

# 5. Program FPGA
open_hw_manager
program_hw_devices [current_hw_device] -program_file ./aes_soc.runs/impl_1/fpga_top.bit
```

---

## Security Considerations

### Key Management

| Approach         | Description                                        |
|------------------|----------------------------------------------------|
| Pre-shared key   | Both devices programmed with same key at manufacturing |
| Key derivation   | Derive session key from master secret + nonce      |
| Key exchange     | Use asymmetric crypto (RSA/ECC) - complex          |

**Recommended**: Pre-shared key for simplicity.

### Replay Attack Prevention

| Mechanism          | Description                                    |
|--------------------|------------------------------------------------|
| Counter/Nonce      | Include incrementing counter in plaintext      |
| Timestamp          | Include timestamp (requires RTC)               |
| Challenge-response | Receiver sends random challenge first          |

### Integrity

AES-128 provides confidentiality, not integrity. For integrity:
- Add HMAC or CMAC
- Use AES-GCM mode (more complex)

---

## Files Created

### Completed Modules

| File                         | Purpose                                | Status |
|------------------------------|----------------------------------------|--------|
| `spi_slave_8lane.v`          | 8-lane parallel SPI slave receiver     | ✅ Done |
| `spi_rx_buffer.v`            | Memory-mapped RX buffer interface      | ✅ Done |
| `aes_soc_device.v`           | Complete SoC wrapper (CPU+AES+SPI)     | ✅ Done |
| `tb_spi_slave_8lane.v`       | Testbench for SPI slave                | ✅ Done |
| `tb_spi_rx_buffer.v`         | Testbench for RX buffer                | ✅ Done |
| `tb_receive_decrypt.v`       | Full receive-decrypt path test         | ✅ Done |
| `tb_bidirectional_simple.v`  | Two-device communication test          | ✅ Done |

### Already Existing (No Changes Needed)

| File                    | Status                                           |
|-------------------------|--------------------------------------------------|
| `picorv32.v`            | Already has pcpi_aes_dec module                  |
| `Aes-Code/Aes-Decryption/*` | Decryption modules exist (fixed minor bug)    |

### Remaining for FPGA

| File                       | Purpose                                |
|----------------------------|----------------------------------------|
| `fpga/fpga_top_bidir.v`    | FPGA top-level for bidirectional comm  |
| `fpga/basys3_bidir.xdc`    | Constraints for Basys3                 |

---

## Test Vectors (FIPS-197)

Use these for verification:

```
Plaintext:  0x00112233445566778899aabbccddeeff
Key:        0x000102030405060708090a0b0c0d0e0f
Ciphertext: 0x69c4e0d86a7b0430d8cdb78070b4c55a
```

---

## System Diagram

```
╔═════════════════════════════════════════════════════════════════════════════╗
║                     COMPLETE SYSTEM ARCHITECTURE                             ║
╠═════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  DEVICE A                              DEVICE B                              ║
║  ┌────────────────────────┐            ┌────────────────────────┐           ║
║  │ ┌──────────────────┐   │            │   ┌──────────────────┐ │           ║
║  │ │    PicoRV32      │   │            │   │    PicoRV32      │ │           ║
║  │ └────────┬─────────┘   │            │   └────────┬─────────┘ │           ║
║  │          │PCPI         │            │            │PCPI       │           ║
║  │    ┌─────┴─────┐       │            │      ┌─────┴─────┐     │           ║
║  │    ▼           ▼       │            │      ▼           ▼     │           ║
║  │ ┌──────┐   ┌──────┐    │            │   ┌──────┐   ┌──────┐  │           ║
║  │ │ AES  │   │ AES  │    │            │   │ AES  │   │ AES  │  │           ║
║  │ │ ENC  │   │ DEC  │    │            │   │ ENC  │   │ DEC  │  │           ║
║  │ └──┬───┘   └──▲───┘    │            │   └──┬───┘   └──▲───┘  │           ║
║  │    │          │        │            │      │          │      │           ║
║  │    ▼          │        │            │      ▼          │      │           ║
║  │ ┌──────┐   ┌──────┐    │            │   ┌──────┐   ┌──────┐  │           ║
║  │ │ SPI  │   │ SPI  │    │  CHANNEL 1 │   │ SPI  │   │ SPI  │  │           ║
║  │ │MASTER│══►│SLAVE │◄═══╬════════════╬═══│MASTER│══►│SLAVE │  │           ║
║  │ │ (TX) │   │ (RX) │    │            │   │ (TX) │   │ (RX) │  │           ║
║  │ └──┬───┘   └──────┘    │            │   └──┬───┘   └──▲───┘  │           ║
║  │    │          ▲        │  CHANNEL 2 │      │          │      │           ║
║  │    │          ╚════════╬════════════╬══════╝          │      │           ║
║  │    ╚═══════════════════╬════════════╬═════════════════╝      │           ║
║  │                        │            │                        │           ║
║  └────────────────────────┘            └────────────────────────┘           ║
║                                                                              ║
║  Legend:  ═══► 8-lane parallel SPI (clk + 8 data + cs_n)                    ║
║           ───► Internal connection                                           ║
║                                                                              ║
╚═════════════════════════════════════════════════════════════════════════════╝
```
